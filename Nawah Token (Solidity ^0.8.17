// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";

contract NawahToken is Initializable, ERC20Upgradeable, OwnableUpgradeable {
    uint256 public transactionFeeBP;         // رسوم المعاملة (بيزيس بوينت 10000 = 100%)
    address public feeCollector;              // عنوان محفظة جمع الرسوم
    uint256 public accumulatedFees;           // رسوم مجمعة لم تُسحب بعد

    // الأحداث
    event FeeCollectorChanged(address indexed previousCollector, address indexed newCollector);
    event TransactionFeeBPChanged(uint256 previousFeeBP, uint256 newFeeBP);
    event FeesWithdrawn(address indexed to, uint256 amount);

    // التهيئة
    function initialize(address initialFeeCollector) public initializer {
        __ERC20_init("Nawah Token", "NWTK");
        __Ownable_init();

        require(initialFeeCollector != address(0), "Fee collector cannot be zero address");
        feeCollector = initialFeeCollector;

        transactionFeeBP = 200; // 2% افتراضياً
        accumulatedFees = 0;

        _mint(msg.sender, 100_000_000 * 10 ** decimals()); // سك 100 مليون توكن
    }

    // تحديث عنوان محفظة الرسوم
    function setFeeCollector(address newCollector) external onlyOwner {
        require(newCollector != address(0), "Fee collector cannot be zero address");
        address oldCollector = feeCollector;
        feeCollector = newCollector;
        emit FeeCollectorChanged(oldCollector, newCollector);
    }

    // تحديث رسوم المعاملات
    function setTransactionFeeBP(uint256 newFeeBP) external onlyOwner {
        require(newFeeBP <= 500, "Fee cannot exceed 5%");
        uint256 oldFee = transactionFeeBP;
        transactionFeeBP = newFeeBP;
        emit TransactionFeeBPChanged(oldFee, newFeeBP);
    }

    // سحب الرسوم المتراكمة
    function withdrawFees() external {
        uint256 amount = accumulatedFees;
        require(amount > 0, "No fees to withdraw");
        require(msg.sender == feeCollector, "Only fee collector can withdraw");

        accumulatedFees = 0;
        _transfer(address(this), feeCollector, amount);

        emit FeesWithdrawn(feeCollector, amount);
    }

    // تجاوز دالة النقل لتضمين خصم رسوم المعاملة
    function _transfer(address sender, address recipient, uint256 amount) internal override {
        if (transactionFeeBP == 0 || sender == feeCollector) {
            // إذا كانت الرسوم صفر أو المرسل هو محفظة الرسوم، لا تخصم رسوم
            super._transfer(sender, recipient, amount);
            return;
        }

        uint256 fee = (amount * transactionFeeBP) / 10000;
        uint256 amountAfterFee = amount - fee;

        // احتساب الرسوم المتراكمة في العقد
        accumulatedFees += fee;

        // نقل المبلغ بعد خصم الرسوم للمستلم
        super._transfer(sender, recipient, amountAfterFee);

        // نقل الرسوم إلى العقد (لتخزينها)
        super._transfer(sender, address(this), fee);
    }
}
